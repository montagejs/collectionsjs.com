{
  "name": "collections",
  "version": "2.0.1",
  "description": "data structures with idiomatic JavaScript collection interfaces",
  "homepage": "http://github.com/montagejs/collections",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal"
  },
  "keywords": [
    "collections",
    "data structures",
    "observable",
    "list",
    "set",
    "map",
    "splay"
  ],
  "bugs": {
    "url": "http://github.com/montagejs/collections/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/montagejs/collections/master/LICENSE.md"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/montagejs/collections.git"
  },
  "dependencies": {
    "weak-map": "^1.0.4"
  },
  "devDependencies": {
    "jasminum": "^2.0.1",
    "sinon": "^1.9.0",
    "istanbul": "^0.2.4",
    "opener": "^1.3.0"
  },
  "scripts": {
    "test": "jasminum spec && jasminum-phantom spec",
    "cover": "istanbul cover spec/index.js spec && istanbul report html && opener coverage/index.html"
  },
  "readme": "[![Build Status](https://travis-ci.org/montagejs/collections.png?branch=master)](http://travis-ci.org/montagejs/collections)\n\n# Collections\n\nThis package contains JavaScript implementations of common data\nstructures with idiomatic iterfaces, including extensions for Array and\nObject.\n\nYou can use these Node Packaged Modules with Node.js, [Browserify][], [Mr][],\n[Mop][], or any compatible CommonJS module loader.  Using a module loader or\nbundler when using Collections in web browsers has the advantage of only\nincorporating the modules you need.\n\n```\nnpm install collections --save\n```\n\n[Browserify]: https://github.com/substack/node-browserify\n[Mr]: https://github.com/montagejs/mr\n[Mop]: https://github.com/montagejs/mop\n\n\n## Collections\n\n### List(values, equals, getDefault)\n\n```javascript\nvar List = require(\"collections/list\");\n```\n\nAn ordered collection of values with fast insertion and deletion and\nforward and backward traversal and splicing, backed by a cyclic doubly\nlinked list with a head node.  Lists support most of the Array\ninterface, except that they use and return nodes instead of integer\nindicies in analogous functions.\n\nLists have a `head` `Node`. The node type is available as `Node` on\nthe list prototype and can be overridden by inheritors.  Each node has\n`prev` and `next` properties.\n\n### Deque(values, capacity)\n\n```javascript\nvar Deque = require(\"collections/deque\");\n```\n\nAn ordered collection of values with fast insertion and deletion and\nforward and backward traversal, backed by a circular buffer that\ndoubles its capacity at need. Deques support most of the Array\ninterface. A Deque is generally faster and produces less garbage\ncollector churn than a List, but does not support fast splicing.\n\n### Set(values, equals, hash, getDefault)\n\n```javascript\nvar Set = require(\"collections/set\");\n```\n\nA collection of unique values.  The set can be iterated in the order\nof insertion.  With a good hash function for the stored values,\ninsertion and removal are fast regardless of the size of the\ncollection.  Values may be objects.  The `equals` and `hash`\nfunctions can be overridden to provide alternate definitions of\n\"unique\".  `Set` is backed by `FastSet` and `List`.\n\n### Map(map, equals, hash, getDefault)\n\n```javascript\nvar Map = require(\"collections/map\");\n```\n\nA collection of key and value entries with unique keys.  Keys may be\nobjects.  The collection iterates in the order of insertion.  `Map`\nis backed by `Set`.\n\n### MultiMap(map, getDefault, equals, hash)\n\n```javascript\nvar MultiMap = require(\"collections/multi-map\");\n```\n\nA collection of keys mapped to collections of values.  The default\n`getDefault` collection is an `Array`, but it can be a `List` or any\nother array-like object.  `MultiMap` inherits `Map` but overrides\nthe `getDefault(key)` provider.\n\n### WeakMap()\n\n```javascript\nvar WeakMap = require(\"collections/weak-map\");\n```\n\nA non-iterable collection of key value pairs.  Keys must objects and\ndo not benefit from `hash` functions.  Some engines already\nimplement `WeakMap`.  The non-iterable requirement makes it possible\nfor weak maps to collect garbage when the key is no longer\navailable, without betraying when the key is collected.  The shimmed\nimplementation undetectably annotates the given key and thus does\nnot necessarily leak memory, but cannot collect certain reference\ngraphs.  This WeakMap shim was implemented by Mark Miller of Google.\n\n### SortedSet(values, equals, compare, getDefault)\n\n```javascript\nvar SortedSet = require(\"collections/sorted-set\");\n```\n\nA collection of unique values stored in stored order, backed by a\nsplay tree.  The `equals` and `compare` functions can be overridden\nto provide alternate definitions of \"unique\".\n\nThe `compare` method *must* provide a total order of all unique\nvalues.  That is, if `compare(a, b) === 0`, it *must* follow that\n`equals(a, b)`.\n\n### SortedMap(map, equals, compare, getDefault)\n\n```javascript\nvar SortedMap = require(\"collections/sorted-map\");\n```\n\nA collection of key value pairs stored in sorted order.  `SortedMap`\nis backed by `SortedSet` and the `GenericMap` mixin.\n\n### LruSet(values, maxLength, equals, hash, getDefault)\n\n```javascript\nvar LruSet = require(\"collections/lru-set\");\n```\n\nA cache with the Least-Recently-Used strategy for truncating its\ncontent when it’s length exceeds `maxLength`.  `LruSet` is backed by\na `Set` and takes advantage of the already tracked insertion order.\nBoth getting and setting a value constitute usage, but checking\nwhether the set has a value and iterating values do not.\n\n### LruMap(map, maxLength, equals, hash, getDefault)\n\n```javascript\nvar LruMap = require(\"collections/lru-map\");\n```\n\nA cache of entries backed by an `LruSet`.\n\n### SortedArray(values, equals, compare, getDefault)\n\n```javascript\nvar SortedArray = require(\"collections/sorted-array\");\n```\n\nA collection of values stored in a stable sorted order, backed by an\narray.\n\n### SortedArraySet(values, equals, compare, getDefault)\n\n```javascript\nvar SortedArraySet = require(\"collections/sorted-array-set\");\n```\n\nA collection of unique values stored in sorted order, backed by a\nplain array.  If the given values are an actual array, the sorted\narray set takes ownership of that array and retains its content.  A\nsorted array set performs better than a sorted set when it has\nroughly less than 100 values.\n\n### SortedArrayMap(values, equals, compare, getDefault)\n\n```javascript\nvar SortedArrayMap = require(\"collections/sorted-array-map\");\n```\n\nA collection of key value pairs stored in sorted order, backed by a\nsorted array set.\n\n### FastSet(values, equals, hash, getDefault)\n\n```javascript\nvar FastSet = require(\"collections/fast-set\");\n```\n\nA collection of unique values stored like a hash table.  The\nunderlying storage is a `Dict` that maps hashes to lists of values\nthat share the same hash.  Values may be objects.  The `equals` and\n`hash` functions can be overridden to provide alternate definitions\nof \"unique\".\n\n### FastMap(map, equals, hash, getDefault)\n\n```javascript\nvar FastMap = require(\"collections/fast-map\");\n```\n\nA collection of key and value entries with unique keys, backed by a\nset.  Keys may be objects.  `FastMap` is backed by `FastSet` and the\n`GenericMap` mixin.\n\n### Dict(values, getDefault)\n\n```javascript\nvar Dict = require(\"collections/dict\");\n```\n\nA collection of string to value mappings backed by a plain\nJavaScript object.  The keys are mangled to prevent collisions with\nJavaScript properties.\n\n### Heap(values, equals, compare)\n\n```javascript\nvar Heap = require(\"collections/heap\");\n```\n\nA collection that can always quickly (constant time) report its\nlargest value, with reasonable performance for incremental changes\n(logarithmic), using a contiguous array as its backing storage.\nHowever, it does not track the sorted order of its elements.\n\n### Iterator(iterable)\n\n```javascript\nvar Iterator = require(\"collections/iterator\");\n```\n\nA wrapper for any iterable that implements `iterate` or iterator the\nimplements `next`, providing a rich lazy traversal interface.\n\n\n### Array\n\n```javascript\nrequire(\"collections/shim-array\");\n```\n\nAn ordered collection of values with fast random access, push, and\npop, but slow splice. The `array` module provides extensions so it\nhosts all the expressiveness of other collections.  The `shim-array`\nmodule shims EcmaScript 5 methods onto the array prototype if they\nare not natively implemented.\n\n### Object\n\n```javascript\nrequire(\"collections/shim-object\");\n```\n\nCan be used as a mapping of owned string keys to arbitrary values.\nThe `object` module provides extensions for the `Object` constructor\nthat support the map collection interface and can delegate to\nmethods of collections, allowing them to gracefully handle both\nobject literals and collections.\n\n## Constructor Arguments\n\nFor all of these constructors, the argument `values` is an optional\ncollection of initial values, and may be an array.  If the `values` are\nin a map collection, the the values are taken, but the keys are ignored.\n\n### map\n\nThe `map` argument is an optional collection to copy shallowly into\nthe new mapping.  The `map` may be an object literal.  If `map`\nimplements `keys`, it is treated as a mapping itself and copied.\nOtherwise, if `map` implements `forEach`, it may be any collection\nof `[key, value]` pairs.\n\n`equals(x, y)`, `compare(x, y)`, and `hash(value)` are all optional\narguments overriding the meaning of equality, comparability, and\nconsistent hashing for the purposes of the collection.  `equals` must\nreturn a boolean.  `compare` must return an integer with the same\nrelationship to zero as x to y.  `hash` should consistently return the\nsame string for any given object.\n\n### equals(x, y)\n\nThe default `equals` operator is implemented in terms of `===`, but\ntreats `NaN` as equal to itself and `-0` as distinct from `+0`.  It\nalso delegates to an `equals` method of either the left or right\nargument if one exists.  The default equality operator is shimmed as\n`Object.equals`.\n\n### compare(x, y)\n\nThe default `compare` operator is implemented in terms of `<` and\n`>`.  It delegates to the `compare` method of either the left or\nright argument if one exists.  It inverts the result if it uses the\nfalls to the right argument.  The default comparator is shimmed as\n`Object.compare`.\n\n### hash(value)\n\nThe default `hash` operator uses `toString` for values and provides\na [Unique Label][] for arbitrary objects.  The default hash is\nshimmed as `Object.hash`.\n\n[Unique Label]: (http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps#unique_labeler)\n\n### getDefault(key or value)\n\nThe default `getDefault` function is `Function.noop`, which returns\n`undefined`.  The fallback function is used when you `get` a\nnonexistant value from any collection.  The `getDefault` function\nbecomes a member of the collection object, so `getDefault` is called\nwith the collection as `this`, so you can also use it to guarantee\nthat default values in a collection are retained, as in `MultiMap`.\n\n\n## Collection Methods\n\nWhere these methods coincide with the specification of an existing\nmethod of Array, Array is noted as an implementation.  `Array+` refers\nto shimmed arrays, as installed with the `array` module.  `Object`\nrefers to methods implemented on the `Object` constructor function, as\nopposed to the `Object.prototype`.  `Object+` in turn refers to methods\nshimmed on the object constructor by the `object` module.  These\nfunctions accept the object as the first argument instead of the `this`\nimplied argument.  ~~Strikethrough~~ indicates an implementation that\nshould exist but has not yet been made (Send a pull request!).\n\nThese are all of the collections:\n\n(Array, Array+, Object+, Iterator, List, Set, Map, MultiMap, WeakMap,\nSortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict)\n\n### has\n\n#### has(key)\n\nWhether a value for the given key exists.\n\n(Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n#### has(value, opt_equals)\n\nWhether a value exists in this collection.  This is slow for list\n(linear), but fast (logarithmic) for SortedSet and SortedArraySet,\nand very fast (constant) for Set.\n\n(Array+, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\nFastSet)\n\n### get\n\n#### get(key or index)\n\nThe value for a key.  If a Map or SortedMap lacks a key, returns\n`getDefault(key)`.\n\n(Array+, Map, SortedMap, SortedArrayMap, WeakMap, Object+)\n\n#### get(value)\n\nGets the equivalent value, or falls back to `getDefault(value)`.\n\n(List, Deque, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\nFastSet)\n\n### set(key or index, value)\n\nSets the value for a key.\n\n(Map, MultiMap, WeakMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n### add\n\n#### add(value)\n\nAdds a value.  Ignores the operation and returns false if an\nequivalent value already exists.\n\n(Array+, List, Deque, Set, SortedSet, LruSet, SortedArray,\nSortedArraySet, FastSet, Heap)\n\n#### add(value, key)\n\nAliases `set(key, value)`, to assist generic methods used for maps,\nsets, and other collections.\n\n### addEach\n\n#### addEach(values)\n\nCopies values from another collection to this one.\n\n(Array+, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\nFastSet, Heap)\n\n#### addEach(mapping)\n\nCopies entries from another collection to this map.  If the mapping\nimplements `keys` (indicating that it is a mapping) and `forEach`,\nall of the key value pairs are copied.  If the mapping only\nimplements `forEach`, it is assumed to contain `[key, value]` arrays\nwhich are copied instead.\n\n(Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n### delete\n\n#### delete(key)\n\nDeletes the value for a given key.  Returns whether the key was\nfound.\n\n(Map, MultiMap, WeakMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n#### delete(value)\n\nDeletes a value.  Returns whether the value was found.\n\n(Set, SortedSet, LruSet, SortedArray, SortedArraySet, FastSet, Heap)\n\n#### delete(value, equals)\n\nDeletes the equivalent value.  Returns whether the value was found.\n\n(Array+, List, Deque)\n\n### deleteEach(values or keys)\n\nDeletes every value or every value for each key.\n\n(Array+, List, Deque, Set, Map, MultiMap, SortedSet, SortedMap,\nLruSet, LruMap, SortedArray, SortedArraySet, SortedArrayMap, FastSet,\nFastMap, Dict, Heap)\n\n### indexOf(value)\n\nReturns the position in the collection of a value, or `-1` if it is\nnot found.  Returns the position of the first of equivalent values.\nFor an Array this takes linear time.  For a SortedArray and\nSortedArraySet, it takes logarithmic time to perform a binary\nsearch.  For a SortedSet, this takes ammortized logarithmic time\nsince it incrementally updates the number of nodes under each\nsubtree as it rotates.\n\n(Array, ~~List~~, Deque, SortedSet, SortedArray, SortedArraySet)\n\n### lastIndexOf(value)\n\nReturns the position in the collection of a value, or `-1` if it is\nnot found.  Returns the position of the last of equivalent values.\n\n(Array, ~~List~~, Deque, SortedArray, SortedArraySet)\n\n### findValue(value, opt_equals)\n\nFinds a value.  For List and SortedSet, returns the node at which\nthe value was found.  For SortedSet, the optional `equals` argument\nis ignored.\n\n(Array+, List, Deque, SortedSet)\n\n### findLastValue(value, opt_equals)\n\nFinds the last equivalent value, returning the node at which the\nvalue was found.\n\n(Array+, List, Deque, SortedArray, SortedArraySet)\n\n### findLeast()\n\nFinds the smallest value, returning the node at which it was found,\nor undefined.  This is fast (logarithmic) and performs no rotations.\n\n(SortedSet)\n\n### findLeastGreaterThan(value)\n\nFinds the smallest value greater than the given value.  This is fast\n(logarithic) but does cause rotations.\n\n(SortedSet)\n\n### findLeastGreaterThanOrEqual(value)\n\nFinds the smallest value greater than or equal to the given value.\nThis is fast (logarithmic) but does cause rotations.\n\n(SortedSet)\n\n### findGreatest()\n\n(SortedSet)\n\n### findGreatestLessThan(value)\n\n(SortedSet)\n\n### findGreatestLessThanOrEqual(value)\n\n(SortedSet)\n\n### push\n\n#### push(...values)\n\nAdds values to the end of a collection.\n\n(Array, List, Deque)\n\n#### push(...values) for non-deques\n\nAdds values to their proper places in a collection.\nThis method exists only to have the same interface as other\ncollections.\n\n(Set, SortedSet, LruSet, SortedArray, SortedArraySet, FastSet, Heap)\n\n### unshift\n\n#### unshift(...values)\n\nAdds values to the beginning of a collection.\n\n(Array, List, Deque)\n\n#### unshift(...values) for non-deques\n\nAdds values to their proper places in a collection.\nThis method exists only to have the same interface as other\ncollections.\n\n(Set, SortedSet, LruSet, SortedArray, SortedArraySet, FastSet)\n\n### pop()\n\nRemoves and returns the value at the end of a collection.  For a\nHeap, this means the greatest contained value, as defined by the\ncomparator.\n\n(Array, List, Deque, Set, SortedSet, LruSet, SortedArray,\nSortedArraySet, Heap)\n\n### shift()\n\nRemoves and returns the value at the beginning of a collection.\n\n(Array, List, Deque, Set, SortedSet, LruSet, SortedArray,\nSortedArraySet)\n\n### peek()\n\nReturns the next value in an deque, as would be returned by the next\n`shift`.\n\n(Array, List, Deque)\n\n### poke(value)\n\nReplaces the next value in an ordered collection, such that it will be\nreturned by `shift` instead of what was there.\n\n(Array, List, Deque)\n\n### peekBack()\n\nReturns the last value in an deque, as would be returned by the next\n`pop`.\n\n(Array, List, Deque)\n\n### pokeBack(value)\n\nReplaces the last value in an ordered collection, such that it will be\nreturned by `pop` instead of what was there.\n\n(Array, List, Deque)\n\n### slice(start, end)\n\nReturns an array of the values contained in the\nhalf-open interval [start, end), that is, including the start and\nexcluding the end.  For lists and arrays, both terms may be numeric\npositive or negative indicies.  For a list, either term may be a\nnode.\n\n(Array, List, SortedSet, SortedArray, SortedArraySet)\n\n### splice(start, length, ...values)\n\nWorks as with an array, but for a list, the start may be an index or\na node.\n\n(Array, List, SortedArray, SortedSet, SortedArraySet)\n\n### swap(start, length, values)\n\nPerforms a splice without variadic arguments.\n\n(Array+, List, SortedArray, SortedSet, SortedArraySet)\n\n### clear()\n\nDeletes the all values.\n\n(Array+, Object+, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### sort(compare)\n\nSorts a collection in place.  The comparator by only be a function.\nThe default comparator coerces unlike types rather than fail to\ncompare.\n\n(Array)\n\n### sorted(compare, by, order)\n\nReturns a collection as an array in sorted order.  Accepts an\noptional `compare(x, y)` function, `by(property(x))` function, and\n`order` indicator, `-1` for descending, `1` for ascending, `0` for\nstable.\n\nInstead of a `compare` function, the comparator can be an object\nwith `compare` and `by` functions.  The default `compare` value is\n`Object.compare`.\n\nThe `by` function must be a function that accepts a value from the\ncollection and returns a representative value on which to sort.\n\n(Array+, List, Deque, Set, Map, SortedSet, LruSet, SortedArray,\nSortedArraySet, FastSet, Heap)\n\n### group(callback, thisp, equals)\n\nReturns an array of [key, equivalence class] pairs where every\nelement from the collection is placed into an equivalence class\nif they have the same corresponding return value from the given\ncallback.\n\n(Array+, Object+, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap, Iterator)\n\n### reverse()\n\nReverses a collection in place.\n\n(Array, List)\n\n### reversed()\n\nReturns a collection of the same type with this collection's\ncontents in reverse order.\n\n(Array, List)\n\n### enumerate(start=0)\n\nReturns an array of [index, value] pairs from the source collection,\nstarting with the given index.\n\n### join(delimiter=\"\")\n\nReturns a string of all the values in the collection joined.\n\n(Array, List, Set, SortedSet, LruSet, SortedArray, SortedArraySet,\nFastSet, Heap, Iterator)\n\n### concat(...iterables)\n\nProduces a new collection of the same type containing all the values\nof itself and the values of any number of other collections.  Favors\nthe last of duplicate values.  For map-like objects, the given\niterables are treated as map-like objects and each successively\nupdates the result.  Array is like a map from index to value.  List,\nSet, and SortedSet are like maps from nodes to values.\n\n(Array, ~~Object+~~, Iterator, List, Set, Map, MultiMap,\nSortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### keys()\n\nReturns an array of the keys.\n\n(Object, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n### values()\n\nReturns an array of the values\n\n(Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n### entries()\n\nReturns an array of `[key, value]` pairs for each entry.\n\n(Object+, Map, MultiMap, SortedMap, LruMap, SortedArrayMap, FastMap,\nDict)\n\n### reduce(callback(result, value, key, object, depth), basis, thisp)\n\n(Array, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### reduceRight(callback(result, value, key, object, depth), basis, thisp)\n\n(Array, List, Deque, SortedSet, ~~SortedMap~~, SortedArray,\nSortedArraySet, ~~SortedArrayMap~~, Heap)\n\n### forEach(callback(value, key, object, depth), thisp)\n\nCalls the callback for each value in the collection.  The iteration\nof lists is resilient to changes to the list.  Particularly, nodes\nadded after the current node will be visited and nodes added before\nthe current node will be ignored, and no node will be visited twice.\n\n(Array, Object+, Iterator, List, Deque, Set, Map, MultiMap, WeakMap,\nSortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### map(callback(value, key, object, depth), thisp)\n\n(Array, Object+, Iterator, List, Deque, Set, Map, MultiMap, WeakMap,\nSortedSet, SortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### toArray()\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### toObject()\n\nConverts any collection to an object, treating this collection as a\nmap-like object.  Array is like a map from index to value.\n\n(Array+ Iterator, List, Deque, Map, MultiMap, SortedMap, LruMap,\nSortedArrayMap, FastMap, Dict, Heap)\n\n### filter(callback(value, key, object, depth), thisp)\n\n(Array, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### every(callback(value, key, object, depth), thisp)\n\nWhether every value passes a given guard.  Stops evaluating the\nguard after the first failure.  Iterators stop consuming after the\nthe first failure.\n\n(Array, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n*The method `all` from version 1 was removed in version 2 in favor of\nthe idiom `every(Boolean)`.*\n\n### some(callback(value, key, object, depth), thisp)\n\nWhether there is a value that passes a given guard.  Stops\nevaluating the guard after the first success.  Iterators stop\nconsuming after the first success.\n\n(Array, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n*The method `any` from version 1 was removed in version 2 in favor of\nthe idiom `some(Boolean)`.*\n\n### min()\n\nThe smallest value.  This is fast for sorted collections (logarithic\nfor SortedSet, constant for SortedArray, SortedArraySet, and\nSortedArrayMap), but slow for everything else (linear).\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict)\n\n### max()\n\nThe largest value.  This is fast for sorted collections (logarithic\nfor SortedSet, constant for SortedArray, SortedArraySet, and\nSortedArrayMap), but slow for everything else (linear).\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### one()\n\nAny single value, or throws an exception if there are no values.  This\nis very fast (constant time) for most collections.  For a sorted set,\n`set.root.value` is always very fast to access, but changes whenever you\n*access* a value, including using `has` or `find`.  In the interest of\nbeing consistent across accesses, and only changing in response to\nmutation, `one` returns the `min` of the set in logarithmic time.\n\n(Array+, List, Deque, Set, Map, MultiMap, SortedSet, SortedMap,\nLruSet, LruMap, SortedArray, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### only()\n\nThe one and only value, or throws an exception if there are no\nvalues or more than one value.\n\n(Array+, List, Deque, Set, Map, MultiMap, SortedSet, SortedMap,\nLruSet, LruMap, SortedArray, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### sum()\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict)\n\n### average()\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict)\n\n### flatten()\n\n(Array+, Iterator, List, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### zip(...collections)\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### enumerate(zero)\n\n(Array+, Iterator, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### clone(depth, memo)\n\nReplicates the collection.  Clones the values deeply, to the\nspecified depth, using the memo to resolve reference cycles.  (which\nmust the `has` and `set` parts of the Map interface, allowing\nobjects for keys)  The default depth is infinite and the default\nmemo is a WeakMap.\n\n`Object.clone` can replicate object literals inheriting directly\nfrom `Object.prototype` or `null`, or any object that implements\n`clone` on its prototype.  Any other object causes `clone` to throw\nan exception.\n\nThe `clone` method on any other objects is not intended to be used\ndirectly since they do not necessarily supply a default depth and\nmemo.\n\n(Array+, Object+, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### constructClone(values)\n\nReplicates a collection shallowly.  This is used by each `clone`\nimplementation to create a new collection of the same type, with the\nsame options (`equals`, `compare`, `hash` options), but it leaves\nthe job of deeply cloning the values to the more general `clone`\nmethod.\n\n(Array+, Object+, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, SortedArray, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict, Heap)\n\n### equals(that, equals)\n\n(Array+, Object+, List, Deque, Set, Map, MultiMap, SortedSet,\nSortedMap, LruSet, LruMap, ~~SortedArray~~, SortedArraySet,\nSortedArrayMap, FastSet, FastMap, Dict)\n\n### compare(that)\n\n(Array+, Object+, List, Deque, ~~SortedArray~~, ~~SortedArraySet~~)\n\n### iterate\n\n#### iterate()\n\nProduces an iterator with a `next` method.  You may elect to get\nricher iterators by wrapping this iterator with an `Iterator` from\nthe `iterator` module.  Iteration order of lists is resilient to\nchanges to the list.\n\n(Array+, Iterator, List, ~~Deque~~, Set, SortedSet, LruSet,\nSortedArray, SortedArraySet, FastSet)\n\n#### iterate(start, end)\n\nReturns an iterator for all values at indicies in the half-open\ninterval [start, end), that is, greater than start, and less than\nend.\n\n(Array+)\n\n#### iterate(start, end)\n\nReturns an iterator for all values in the half-open interval [start,\nend), that is, greater than start, and less than end.  The iterator\nis resilient against changes to the data.\n\n(SortedSet)\n\n### log(charmap, callback(node, write, writeAbove), log, logger)\n\nWrites a tree describing the internal state of the data structure to\nthe console.\n\n`charmap` is an object that notes which characters to use to draw\nlines.  By default, this is the `TreeLog.unicodeRound` property from the\n`tree-log` module.  `TreeLog.unicodeSharp` and `TreeLog.ascii` are\nalternatives.  The properties are:\n\n-   intersection: ╋\n-   through: ━\n-   branchUp: ┻\n-   branchDown: ┳\n-   fromBelow: ╭\n-   fromAbove: ╰\n-   fromBoth: ┣\n-   strafe: ┃\n\n`callback` is a customizable function for rendering each node of the tree.\nBy default, it just writes the value of the node.  It accepts the node and\na writer functions.  The `write` function produces the line on which the\nnode joins the tree, and each subsequent line.  The `writeAbove` function\ncan write lines before the branch.\n\n`log` and `logger` default to `console.log` and `console`.  To write\nthe representation to an array instead, they can be `array.push` and\n`array`.\n\n(SortedSet)\n\n\n### Iterator(iterable, start, stop, step)\n\n*Redesigned in version 2.*\n\nCreates an iterator from an iterable. Iterables include:\n\n-   instances of Iterator, in which case the “iterable” will be simply returned\n    instead of a new iterator.\n-   objects with an `iterate(start, stop, step)` method, in which case the\n    optional `start`, `stop`, and `step` arguments are forwarded. Collections\n    implement this iterface, including Array.\n-   objects with a `next()` method, which is to say existing iterators,\n    though this iterator will only depend on the `next()` method and provide\n    the much richer Iterator interface using it.\n-   `next()` functions.\n\nIterators are defined by the upcoming version of ECMAScript. The `next()` method\nreturns what I am calling an “iteration”, an object that has a `value` property\nand an optional `done` flag. When `done` is true, the iteration signals the end\nof the iterator and may be accompanied by a “return value” instead of a “yield\nvalue”.\n\nIn addition, Iterator produces iterations with an optional `index` property. The\nindexes produced by an array are the positions of each value, which are\nnon-contiguous for sparse arrays.\n\n*In version 1, iterators followed the old, Pythonic protocol established in\nMozilla’s SpiderMonkey, where iterators yielded values directly and threw\n`StopIteration` to terminate.*\n\n#### dropWhile(callback(value, index, iterator), thisp)\n\nReturns an iterator that begins with the first iteration from this iterator to\nfail the given test.\n\n#### takeWhile(callback(value, index, iterator), thisp)\n\nReturns an iterator that ends before the first iteration from this iterator to\nfail the given test.\n\n#### iterateMap(callback(value, index, iterator))\n\n*Renamed in version 2 from `mapIterator` in version 1.*\n\nReturns an iterator for a mapping on the source values.  Values are\nconsumed on demand.\n\n#### iterateFilter(callback(value, index, iterator))\n\n*Renamed in version 2 from `filterIterator` in version 1.*\n\nReturns an iterator for those values from the source that pass the\ngiven guard.  Values are consumed on demand.\n\n#### iterateZip(...iterables)\n\n*Introduced in version 2.*\n\nReturns an iterator that incrementally combines the respective\nvalues of the given iterations, first including itself.\n\n#### iterateUnzip()\n\n*Introduced in version 2.*\n\nAssuming that this is an iterator that produces iterables, produces an iteration\nof the reslective values from each iterable.\n\n#### iterateConcat(...iterables)\n\n*Renamed in version 2 from `concat` in version 1.*\n\nCreates an iteration that first produces all the values from this iteration,\nthen from each subsequent iterable in order.\n\n#### iterateFlatten()\n\n*Introduced in version 2.*\n\nAssuming that this is an iterator that produces iterables, creates an iterator\nthat yields all of the values from each of those iterables in order.\n\n#### iterateEnumerate(start = 0)\n\n*Renamed in version 2 from `enumerateIterator` in version 1.*\n\nReturns an iterator that provides [index, value] pairs from the\nsource iteration.\n\n#### recount(start=0)\n\n*Introduced in version 2.*\n\nProduces a new version of this iteration where the indexes are recounted. The\nindexes for sparse arrays are not contiguous, as well as the iterators produced\nby `filter`, `cycle`, `flatten`, and `concat` that pass iterations through\nwithout alteration from various sources. `recount` smoothes out the sequence.\n\n\n### Iterator utilities\n\n#### cycle(iterable, times=Infinity)\n\nProduces an iterator that will cycle through the values from a given iterable\nsome number of times, indefinitely by default. The given iterable must be able\nto produce the sequence of values each time it is iterated, which is to say, not\nan iterator, but any collection would do.\n\n#### unzip(iterables)\n\nTransposes a two dimensional iterable, which is to say, produces an iterator\nthat will yield a tuple of the respective values from each of the given\niterables.\n\n#### zip(...iterables)\n\nTransposes a two dimensional iterable, which is to say, produces an iterator\nthat will yield a tuple of the respective values from each of the given\niterables. `zip` differs from `unzip` only in that the arguments are variadic.\n\n#### flatten(iterables)\n\n*Renamed in version 2 from `concat` in version 1.*\n\nReturns an iterator that will produce all the values from each of the given\niterators in order.\n\n#### concat(...iterables)\n\n*Renamed in version 2 from `chain` in version 1.*\n\nReturns an iterator that will produce all the values from each of the given\niterators in order. Differs from `flatten` only in that the arguments are\nvariadic.\n\n#### range(length)\n\nIterates `length` numbers starting from 0.\n\n#### range(start, stop, step=1)\n\nIterates numbers from start to stop by step.\n\n#### count(start, step)\n\nIterates numbers from start by step, indefinitely.\n\n#### repeat(value, times)\n\nRepeats the given value either finite times or indefinitely.\n\n\n## Change Observers\n\n*Introduced in version 2.*\n\nAll collections support change observers. There are three types of changes.\nProperty changes, range changes, and map changes. Whether a collection supports\na kind of change can be inferred by the existence of an `observe*` method\nappropriate to the kind of change, `observeRangeChange` for example.\n\n#### Observers\n\nThe `observe*` methods all return “observer” objects with some overlapping\ninterface. Most importantly, an “observer” has a `cancel()` method that will\nremove the observer from the queue of observers for its corresponding object and\nproperty name. To reduce garbage collection churn, the observer may be reused,\nbut if the observer is canceled during change dispatch, it will not be recycled\nuntil all changes have been handled. Also, if an observer is cancelled during\nchange dispatch, it will be passed over. If an observer is created during change\ndispatch, it will also be passed over, to be informed of any subsequent changes.\n\nThe observer will have a `handlerMethodName` property, based on a convention\nthat take into account all the parameters of the change observer and what\nmethods are available on the handler, such as `handleFooPropertyWillChange` or\nsimply null if the handler is a function. This method name can be overridden if\nyou need to break from convention.\n\nThe observer will also have a `dispatch` method that you can use to manually\nforce a change notification.\n\nThe observer will have a `note` property, as provided as an argument to the\nobserve method. This value is not used by the change observer system, but is\nleft for the user, for example to provide helpful information for inspecting why\nthe observer exists and what systems it participates in.\n\nThe observer will have a `childObserver` property. Handlers have the option of\nreturning an observer, if that observer needs to be canceled when this observer\nnotices a change. This facility allows observers to “stack”.\n\nAll kinds of changes have a `get*ChangeObservers` method that will return an\narray of change observers. This function will consistently return the same array\nfor the same arguments, and the content of the array is itself observable.\n\n#### Handlers\n\nA handler may be an object with a handler method or a function. Either way, the\nchange observer will dispatch an argument pattern to the observer including both\nthe new and old values associated with the change and other parameters that\nallow generic handlers to multiplex changes from multiple sources. See the\nspecific change observer documentation for details about the argument pattern\nand handler method name convention.\n\nAgain, a handler has the option of returning an observer. This observer will be\ncanceled if there is a subsequent change. So for example, if you are observing\nthe \"children\" property of the \"root\" property of a tree, you would be able to\nstack the \"children\" property observer on top of the \"root\" property observer,\nensuring that the children property observer does not linger on old roots.\n\nIf a handler throws an exception, it will not corrupt the state of the change\nnotification system, but it may corrupt the state of the observed object and the\nassuptions of the rest of the program. Such errors are annotated by the change\ndispatch system to increase awareness that all such errors are irrecoverable\nprogrammer errors.\n\n#### Capture\n\nAll observers support “change” and “will change” (“capture”) phases. Both phases\nreceive both the old and new values, but in the capture phase, the direct\ninterrogation of the object being observed will show that the change has not\ntaken effect, though change observers do not provide a facility for preventing a\nchange and throwing exceptions can corrupt the state of involved collections.\nAll “will change” methods exist to increase the readability of the program but\nsimply forward a true “capture” argument to the corresponding “change” method.\nFor example, `map.observeMapWillChange(handler)` just calls\n`map.observeMapChange(handler, null, null, true)`, eliding the `name` and `note`\narguments not provided.\n\n### Property Changes\n\nThe `observable-object` module provides facilities for observing changes to\nproperties on arbitrary objects, as well as a mix-in prototype that allows any\ncollection to support the property change observer interface directly. The\n`observable-array` module alters the `Array` in this context to support the\nproperty observer interface for its `\"length\"` property and indexed properties\nby number, as long as those properties are altered by a method of the array\n(which is to say, *caveat emptor: direct assignment to a property of an array is\nnot observable*). This shim does not introduce any overhead to arrays that are\nnot observed.\n\n```javascript\nvar ObservableObject = require(\"collections/observable-object\");\nObservableObject.observePropertyChange(object, name, handler, note, capture);\nObservableObject.observePropertyWillChange(object, name, handler, note, capture);\nObservableObject.dispatchPropertyChange(object, plus, minus);\nObservableObject.dispatchPropertyWillChange(object, plus, minus);\nObservableObject.getPropertyChangeObservers(object, name, capture)\nObservableObject.getPropertyWillChangeObservers(object, name, capture)\nObservableObject.makePropertyObservable(object, name);\nObservableObject.preventPropertyObserver(object, name);\n```\n\nAll of these methods delegate to methods of the same name on an object if one\nexists, making it possible to use these on arbitrary objects as well as objects\nwith custom property observer behavior. The property change observer interface\ncan be imbued on arbitrary objects.\n\n```javascript\nObject.addEach(Constructor.prototype, ObservableObject.prototype);\nvar object = new Constructor();\n\nobject.observePropertyChange(name, handler, note, capture);\nobject.observePropertyWillChange(name, handler, note);\nobject.dispatchPropertyChange(plus, minus, capture);\nobject.dispatchPropertyWillChange(plus, minus);\nobject.getPropertyChangeObservers(name, capture)\nobject.getPropertyWillChangeObservers(name)\nobject.makePropertyObservable(name);\nobject.preventPropertyObserver(name);\n```\n\n`observePropertyChange` and `observePropertyWillChange` accept a property\n`name` and a `handler` and returns an `observer`.\n\n#### Handlers\n\nThe arguments to a property change handler are:\n\n-   `plus`: the new value\n-   `minus`: the old value\n-   `name` (`observer.propertyName`, the `name` argument to\n    `observePropertyChange`)\n-   `object` (`observer.object`, the `object` given to `observePropertyChange`)\n-   `this` is the `handler` or undefined if the handler is a callable.\n\nThe prefereed handler method name for a property change observer is composed:\n\n-   `\"handle\"`\n-   `name`, with the first character capitalized\n-   `\"Property\"`\n-   `\"Will\"` if `capture`\n-   `\"Change\"`\n\n*The specific handler method name differs from those constructed by version 1,\nin that it includes the term, `\"Property\"`. Thus, all observer handler method\nnames now receive a complete description of the kind of change, at the expense\nof some verbosity.*\n\nIf this method does not exist, the method name falls back to the generic without\nthe property name:\n\n-   `\"handle\"`\n-   `\"Property\"`\n-   `\"Will\"` if `capture`\n-   `\"Change\"`\n\nOtherwise, the handler must be callable, implementing `handler.call(this, plus,\nminus, name, object)`, but not necessarily a function.\n\n#### Observers\n\nA property change observer has properties in addition to those common to all\nobservers.\n\n-   `propertyName`\n-   `value` the last value dispatched. This will be used if `minus` is not given\n    when a change is dispatched and is otherwise is useful for inspecting\n    observers.\n\n#### Observability\n\nProperty change observers use various means to make properties observable. In\ngeneral, they install a “thunk” property on the object that intercepts `get` and\n`set` calls. A thunk will never be installed over an existing thunk.\n\nObservers take great care to do what makes sense with the underlying property\ndescriptor. For example, different kinds of thunks are installed for descriptors\nwith `get` and `set` methods than those with a simple `value`. If a property is\nread-only, either indicated by `writable` being false or `get` being provided\nwithout a matching `set`, no thunk is installed at all.\n\nIf a property is ostensibly immutable, for lack of a `set` method, but the value\nreturned by `get` does in fact change in response to exogenous changes, those\nchanges may be rigged to dispatch a property change manually, using one of the\nabove `dispatch` methods.\n\nTo avoid installing a thunk on every instance of particular constructor,\n`makePropertyObservable` can be applied to a property of a prototype. To avoid\ninstalling a thunk on a property at all, `preventPropertyObserver` can be\napplied to either an instance or a prototype.\n\nProperties of an `Array` cannot be observed with thunks, so the\n`observable-array` module adds methods to the Array prototype that allow it to\nbe transformed into an observed array on demand. The transformation involves\nreplacing all the methods that modify the content of the array with versions\nthat report the changes. The observable array interface is installed either by\nsubverting the prototype of the instance, or by redefining these methods\ndirectly onto the instance if the prototype is not mutable.\n\n### Range Changes\n\nMany collections represent a contiguous range of values in a fixed order. For\nthese collections, range change observation is available.\n\n-   `Array` with `require(\"collections/observable-array\")`\n-   `List`&dagger;\n-   `Deque`\n-   `Set`&dagger;\n-   `SortedSet`\n-   `SortedArray`\n-   `SortedArraySet`\n-   `Heap`\n\n*&dagger;Note that with `List` and `Set`, observing range changes often\nnullifies any performance improvment that might be gained using them instead of\nan array, deque, or array-backed set.*\n\n`SortedSet` can grow to absurd proportions and still quickly dispatch range\nchange notifications at any position, owing to an algorithim that can\nincrementally track the index of each node in time proportional to the logarithm\nof the size of the collection.\n\nThe `observe-range-changes` module exports a **mixin** that provides the range\nchange interface for a collection.\n\n```javascript\ncollection.observeRangeChange(handler, name, note, capture)\ncollection.observeRangeWillChange(handler, name, note)\ncollection.dispatchRangeChange(plus, minus, index, capture)\ncollection.dispatchRangeWillChange(plus, minus, index)\ncollection.getRangeChangeObservers(capture)\ncollection.getRangeWillChangeObservers()\ncollection.makeRangeChangeObservable()\n```\n\nThe `name` is optional and only affects the handler method name computation.\nThe convention for the name of a range change handler method name is:\n\n-   `\"handle\"`\n-   `name` with the first character capitalized, if given, and only if the\n    resulting method name is available on the handler.\n-   `\"Range\"`\n-   `\"Will\"` if `capture`\n-   `\"Change\"`\n\nThe arguments of a range change are:\n\n-   `plus`: values added at `index`\n-   `minus`: values removed at `index` before `plus` was added\n-   `index`\n-   `collection`\n\nThe `makeRangeChangeObservable` method is overridable if a collection needs to\nperform some operations apart from setting `dispatchesRangeChanges` in order to\nbecome observable. For example, a `Set` has to establish observers on its own\n`order` storage list.\n\n### Map Changes\n\n*Note: map change observers are very different than version 1 map change\nlisteners.*\n\nMany collections represent a mapping from keys to values, irrespective of order.\nFor most of these collections, map change observation is available.\n\n-   `Array` with `require(\"collections/observable-array\")`\n-   `Map`\n-   `FastMap`\n-   `LruMap`\n-   `SortedMap`\n-   `SortedArrayMap`\n-   `Dict`\n-   `Heap` only for key 0\n\n```javascript\ncollection.observeMapChange(handler, name, note, capture)\ncollection.observeMapWillChange(handler, name, note)\ncollection.dispatchMapChange(plus, minus, index, capture)\ncollection.dispatchMapWillChange(plus, minus, index)\ncollection.getMapChangeObservers(capture)\ncollection.getMapWillChangeObservers()\ncollection.makeMapChangeObservable()\n```\n\nThe `name` is optional and only affects the handler method name computation.\nThe convention for the name of a range change handler method name is:\n\n-   `\"handle\"`\n-   `name` with the first character capitalized, if given, and only if the\n    resulting method name is available on the handler.\n-   `\"Map\"`\n-   `\"Will\"` if `capture`\n-   `\"Change\"`\n\nThe arguments of a range change are:\n\n-   `plus`: the new value\n-   `minus`: the old value\n-   `key`\n-   `type`: one of `\"create\"`, `\"update\"`, or `\"delete\"`\n-   `collection`\n\nThe `makeMapChangeObservable` method is overridable if a collection needs to\nperform some operations apart from setting `dispatchesMapChanges` in order to\nbecome observable.\n\n\n## Change Listeners\n\n*The change listener interface exists in version 1, but has been replaced with\nChange Observers in version 2.*\n\nAll collections support change listeners.  There are three types of\nchanges.  Property changes, map changes, and range changes.\n\n### Property Changes\n\n`PropertyChanges` from the `listen/property-changes` module can\nconfigure listeners for property changes to specific keys of any object.\n\nWith the `listen/array-changes` module required, `PropertyChanges` can\nalso listen to changes to the length and indexed properties of an array.\nThe only caveat is that watched arrays can only modify their contents\nwith method calls like `array.push`.  All methods of a watched array\nsupport change dispatch.  In addition, arrays have a `set` method to\nmake setting the value at a particular index observable.\n\n-   PropertyChanges.addOwnPropertyChangeListener(object, key, listener, before)\n-   PropertyChanges.removeOwnPropertyChangeListener(object, key, listener, before)\n-   PropertyChanges.dispatchOwnPropertyChange(object, key, value, before)\n-   PropertyChanges.addBeforeOwnPropertyChangeListener(object, key, listener)\n-   PropertyChanges.removeBeforeOwnPropertyChangeListener(object, key, listener)\n-   PropertyChanges.dispatchBeforeOwnPropertyChange(object, key, value)\n-   PropertyChanges.getOwnPropertyChangeDescriptor(object, key)\n\nAll of these functions delegate to methods of the same name if one\nexists on the object.\n\n-   object.addOwnPropertyChangeListener(key, listener, before)\n-   object.removeOwnPropertyChangeListener(key, listener, before)\n-   object.dispatchOwnPropertyChange(key, value, before)\n-   object.addBeforeOwnPropertyChangeListener(key, listener)\n-   object.removeBeforeOwnPropertyChangeListener(key, listener)\n-   object.dispatchBeforeOwnPropertyChange(key, value)\n-   object.getOwnPropertyChangeDescriptor(key)\n\nAdditionally, `PropertyChanges.prototype` can be **mixed into** other\ntypes of objects to support the property change dispatch interface.  All\ncollections support this interface.\n\nThe **listener** for a property change receives the arguments `value`,\n`key`, and `object`, just as a `forEach` or `map` callback.  The\nlistener may alternately be a delegate object that implements one of\nthese methods:\n\n-   listener.handle + **key** + Change **or** WillChange\n-   listener.handleProperty + Change **or** WillChange\n-   listener.call\n\n### Map Changes\n\nA map change listener receives notifications for the creation, removal,\nor updates for any entry in a map data structure.\n\nWith the `listen/array-changes` module required, `Array` can also\ndispatch map changes for the values at each index.\n\n-   collection.addMapChangeListener(listener, token, before)\n-   collection.removeMapChangeListener(listener, token, before)\n-   collection.dispatchMapChange(key, value, before)\n-   collection.addBeforeMapChangeListener(listener)\n-   collection.removeBeforeMapChangeListener(listener)\n-   collection.dispatchBeforeMapChange(key, value)\n-   collection.getMapChangeDescriptor()\n\nThe **listener** for a map change receives the `value`, `key`, and\ncollection `object` as arguments, the same pattern as a `forEach` or\n`map` callback.  In the after change phase, a value of `undefined` may\nindicate that the value was deleted or set to `undefined`.  In the\nbefore change phase, a value of `undefined` may indicate the the value\nwas added or was previously `undefined`.\n\nThe listener may be a delegate object with one of the following methods,\nin order of precedence:\n\n-   listener.handleMap + Change **or** WillChange\n-   listener.handle + **token** + Map + Change **or** WillChange\n-   listener.call\n\nThe `listen/map-changes` module exports a map changes **mixin**.  The\nmethods of `MaxChanges.prototype` can be copied to any collection that\nneeds this interface.  Its mutation methods will then need to dispatch\nmap changes.\n\n### Range Changes\n\nA range change listener receives notifications when a range of values at\na particular position is added, removed, or replaced within an ordered\ncollection.\n\n-   collection.**add**RangeChange**Listener**(listener, token, before)\n-   collection.**remove**RangeChange**Listener**(listener, token, before)\n-   collection.**dispatch**RangeChange(plus, minus, index, before)\n-   collection.add**Before**RangeChange**Listener**(listener)\n-   collection.remove**Before**RangeChange**Listener**(listener)\n-   collection.dispatch**Before**RangeChange(plus, minus, index)\n-   collection.**get**RangeChange**Descriptor**()\n\nThe **listener** for a range change is a function that accepts `plus`,\n`minus`, and `index` arguments.  `plus` and `minus` are the values that\nwere added or removed at the `index`.  Whatever operation caused these\nchanges is equivalent to:\n\n```javascript\nvar minus = collection.splice(index, minus.length, ...plus)\n```\n\nThe listener can alternately be a delegate object with one of the\nfollowing methods in order of precedence:\n\n-   handle + **token** + Range + Change **or** WillChange\n-   handleRange + Change **or** WillChange\n-   call\n\nThe following support range change dispatch:\n\n-   `Array` with `require(\"collections/listen/array-changes\")`\n-   `SortedSet`\n-   `SortedArray`\n-   `SortedArraySet`\n\nThe `listen/range-changes` module exports a range changes **mixin**.\nThe methods of `RangeChanges.prototype` can be copied to any collection\nthat needs this interface.  Its mutation methods will need to dispatch\nthe range changes.\n\nAll **descriptors** are objects with the properties `changeListeners`\nand `willChangeListeners`.  Both are arrays of listener functions or\nobjects, in the order in which they were added.\n\n\n## Miscellanea\n\n### Set and Map\n\nSet and map are like hash tables, but not implemented with a block of\nmemory as they would be in a lower-level language.  Most of the work of\nproviding fast insertion and lookup based on a hash is performed by the\nunderlying plain JavaScript object.  Each key of the object is a hash\nstring and each value is a List of values with that hash.  The inner\nlist resolves collisions.  With a good `hash` method, the use of the\nlist can be avoided.\n\nSets and maps both have a `log` function that displays the internal\nstructure of the bucket list in an NPM-style.\n\n```\n┣━┳ 1\n┃ ┗━━ {\"key\":1,\"value\":\"a\"}\n┣━┳ 2\n┃ ┣━━ {\"key\":2,\"value\":\"c\"}\n┃ ┗━━ {\"key\":2,\"value\":\"d\"}\n┗━┳ 3\n  ┗━━ {\"key\":3,\"value\":\"b\"}\n```\n\n\n### Sorted Set and Sorted Map\n\nA binary splay tree is a balanced binary tree that rotates the most\nfrequently used entries toward the root such that they can be accessed the\nmost quickly.  `sorted-set` and `sorted-map` are backed by a splay tree.\n\nAll map implementations use an underlying set implementation.  Any map\ncan be implemented trivially atop a set by wrapping `compare`, `equals`,\nor `hash` to operate on the key of an entry.\n\nThe sorted set has a `root` node.  Each node has a `left` and `right`\nproperty, which may be null.  Nodes are returned by all of the \"find\"\nfunctions, and provided as the `key` argument to callbacks.\n\nBoth `sorted-set` and `sorted-map` implement a `log` function which can\nproduce NPM-style visualizations of the internal state of the sorted\ntree.\n\n```\n> set.log(SortedSet.ascii)\n  .-+ -3\n  | '-- -2\n.-+ -1\n+ 0\n| .-- 1\n'-+ 2\n  '-- 3\n```\n\n```\n> set.log(SortedSet.unicodeRound)\n  ╭━┳ -3\n  ┃ ╰━━ -2\n╭━┻ -1\n╋ 0\n┃ ╭━┳ 1\n┃ ┃ ╰━━ 2\n╰━┻ 3\n```\n\n\n### Object and Function Shims\n\nThe collection methods on the `Object` constructor all polymorphically\ndelegate to the corresponding method of any object that implements the\nmethod of the same name.  So, `Object.has` can be used to check whether\na key exists on an object, or in any collection that implements `has`.\nThis permits the `Object` interface to be agnostic of the input type.\n\n`Array.from` creates an array from any iterable.\n\n`Array.unzip` transposes a collection of arrays, so rows become columns.\n\n`Array.empty` is an empty array, frozen if possible.  Do not modify it.\n\n`Object.from` creates an object from any map or collection.  For arrays\nand array-like collections, uses the index for the key.\n\n`Object.empty` is an empty object literal.\n\n`Object.isObject(value)` tests whether it is safe to attempt to access\nproperties of a given value.\n\n`Object.is(x, y)` compares objects for exact identity and is a good\nalternative to `Object.equals` in many collections.\n\n`Object.getValueOf(value)` safely and idempotently returns the value of\nan object or value by only calling the `valueOf()` if the value\nimplements that method.\n\n`Object.owns` is a shorthand for `Object.prototype.hasOwnProperty.call`.\n\n`Object.can(value, name)` checks whether an object implements a method\non its prototype chain.  An owned function property does not qualify as\na method, to aid in distinguishing \"static\" functions.\n\n`Object.concat(...maps)` and `Object.from(entries)` construct an object\nby adding the entries of other objects in order.  The maps can be other\nobjects, arrays of entries, or map alike collections.\n\n`Function.noop` is returns undefined.\n\n`Function.identity` returns its first argument.\n\n`Function.by(relation)` creates a comparator from a relation function.\n\n`Function.get(key)` creates a relation that returns the value for the\nproperty of a given object.\n\n\n### References\n\n- a SplayTree impementation buried in Fedor Indutny’s super-secret\n  [Callgrind](https://github.com/indutny/callgrind.js). This\n  implementation uses parent references.\n- a SplayTree implementation adapted by [Paolo\n  Fragomeni](https://github.com/hij1nx/forest) from the V8 project and\n  based on the top-down splaying algorithm from \"Self-adjusting Binary\n  Search Trees\" by Sleator and Tarjan. This does not use or require\n  parent references, so I favored it over Fedor Indutny’s style.\n- the interface of ECMAScript harmony [simple maps and\n  sets](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)\n- a SplayTree implementation from [JavaScript data\n  structures](derrickburns/Javascript-Data-Structures) mainted by\n  Derrick Burns that supports change-resilient iterators and a\n  comprehensive set of introspection functions.\n\n### Future work\n\nGoals\n\n- make array dispatch length property changes between range changes to\n  be consistent with List.\n- automate the generation of the method support tables in readme and\n  normalize declaration order\n- rearchitect ordered collections in terms of iteration instead of reduction,\n  at least for methods that short circuit like some and every\n- eliminate any/all\n- comprehensive specs and spec coverage tests\n- fast list splicing\n- Make it easier to created a SortedSet with a criterion like\n  Function.by(Function.get('name'))\n\nMore possible collections\n\n- sorted-list (sorted, can contain duplicates, perhaps backed by splay\n  tree with relaxation on the uniqueness invariant, or a skip list)\n- sorted-multi-map (sorted, can contain duplicate entries)\n- buffer (backed by a circular array, emits cull events)\n- trie-set\n- trie-map\n- immutable-* (mutation functions return new objects that largely share\n  the previous version's internal state, some perhaps backed by a hash\n  trie)\n- array-set (a set, for fast lookup, backed by an array for meaningful\n  range changes)\n\n",
  "readmeFilename": "README.md",
  "_id": "collections@2.0.1",
  "_from": "collections@>=2.0.1 <3.0.0"
}
